.TH "ComandosResto" 3 "Domingo, 7 de Mayo de 2017" "Version 3.0" "Practica RedesII" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ComandosResto \- 
.SS "Funciones"

.in +1c
.ti -1c
.RI "void \fBliberarEstructuras\fP (void)"
.br
.RI "\fILibera estructuras antes de cerrar servidor\&. \fP"
.ti -1c
.RI "void * \fBmanejaMensaje\fP (void *pdesc)"
.br
.RI "\fIParsea el mensaje recibido\&. \fP"
.ti -1c
.RI "\fBstatus\fP \fBprocesaComando\fP (char *comando, \fBpDatosMensaje\fP datos)"
.br
.RI "\fISelecciona comando del array a ejecutar\&. \fP"
.ti -1c
.RI "\fBstatus\fP \fBnuevaConexion\fP (int desc, struct sockaddr_in *address)"
.br
.RI "\fICrea una nueva conexion\&. \fP"
.ti -1c
.RI "\fBstatus\fP \fBcerrarConexion\fP (int socket)"
.br
.RI "\fICierra una conexion\&. \fP"
.ti -1c
.RI "void \fBliberaDatosMensaje\fP (\fBpDatosMensaje\fP datos)"
.br
.RI "\fILibera informacion del mensaje\&. \fP"
.ti -1c
.RI "\fBstatus\fP \fBcrea_comandos\fP (void)"
.br
.RI "\fIInicializa el array de comandos\&. \fP"
.ti -1c
.RI "\fBstatus\fP \fBliberarUserData\fP (char *\fBuser\fP, char *\fBnick\fP, char *real, char *host, char *IP, char *\fBaway\fP)"
.br
.RI "\fIInicializa rutina ping-pong\&. \fP"
.ti -1c
.RI "void \fBwhoischannels\fP (int sckfd, char *nick1, char *nick2, char *\fBuser\fP, char *target)"
.br
.RI "\fIFuncion auxiliar para el comando WHOIS\&. \fP"
.ti -1c
.RI "void \fBsendAway\fP (int sckfd, char *\fBaway\fP, char *\fBnick\fP, char *nickorig)"
.br
.RI "\fIFuncion auxiliar para el comando WHOIS\&. \fP"
.ti -1c
.RI "\fBstatus\fP \fBwhois\fP (char *comando, \fBpDatosMensaje\fP datos)"
.br
.RI "\fIEjecuta el comando WHOIS\&. \fP"
.ti -1c
.RI "void \fBlistarNamesCanal\fP (char *canal, int sckfd, char *prefijo, char *nicku)"
.br
.RI "\fIFuncion auxiliar para el comando NAMES\&. \fP"
.ti -1c
.RI "\fBstatus\fP \fBnames\fP (char *comando, \fBpDatosMensaje\fP datos)"
.br
.RI "\fIEjecuta el comando NAMES\&. \fP"
.ti -1c
.RI "void \fBenviarMensajePrivado\fP (int sckfd, char *mensaje, char *\fBnick\fP, char *nickorigin, int sndaway)"
.br
.RI "\fIFuncion auxilar del comando PRIVMSG\&. \fP"
.ti -1c
.RI "void \fBenviarMensajeACanal\fP (int sckfd, char *mensaje, char *canal, char *nickorigin)"
.br
.RI "\fIFuncion auxilar del comando PRIVMSG\&. \fP"
.ti -1c
.RI "\fBstatus\fP \fBprivmsg\fP (char *comando, \fBpDatosMensaje\fP datos)"
.br
.RI "\fIEjecuta el comando PRIVMSG\&. \fP"
.ti -1c
.RI "\fBstatus\fP \fBping\fP (char *comando, \fBpDatosMensaje\fP datos)"
.br
.RI "\fIEjecuta el comando PING\&. \fP"
.ti -1c
.RI "\fBstatus\fP \fBpong\fP (char *comando, \fBpDatosMensaje\fP datos)"
.br
.RI "\fIEjecuta el comando PONG\&. \fP"
.ti -1c
.RI "void \fBpartirCanal\fP (int sckfd, char *canal, char *\fBnick\fP, char *real, char *msg)"
.br
.RI "\fIFuncion auxilar del comando PART\&. \fP"
.ti -1c
.RI "\fBstatus\fP \fBpart\fP (char *comando, \fBpDatosMensaje\fP datos)"
.br
.RI "\fIEjecuta el comando PART\&. \fP"
.ti -1c
.RI "\fBstatus\fP \fBtopic\fP (char *comando, \fBpDatosMensaje\fP datos)"
.br
.RI "\fIEjecuta el comando TOPIC\&. \fP"
.ti -1c
.RI "\fBstatus\fP \fBkick\fP (char *comando, \fBpDatosMensaje\fP datos)"
.br
.RI "\fIEjecuta el comando KICK\&. \fP"
.ti -1c
.RI "\fBstatus\fP \fBaway\fP (char *comando, \fBpDatosMensaje\fP datos)"
.br
.RI "\fIEjecuta el comando AWAY\&. \fP"
.ti -1c
.RI "\fBstatus\fP \fBmode\fP (char *comando, \fBpDatosMensaje\fP datos)"
.br
.RI "\fIEjecuta el comando MODE\&. \fP"
.ti -1c
.RI "\fBstatus\fP \fBquit\fP (char *comando, \fBpDatosMensaje\fP datos)"
.br
.RI "\fIEjecuta el comando QUIT\&. \fP"
.ti -1c
.RI "char * \fBgetMOTD\fP (void)"
.br
.RI "\fIObtiene ruta del motd a mostrar\&. \fP"
.ti -1c
.RI "\fBstatus\fP \fBmotd\fP (char *comando, \fBpDatosMensaje\fP datos)"
.br
.RI "\fIEjecuta el comando MOTD\&. \fP"
.ti -1c
.RI "\fBstatus\fP \fBcomandoVacio\fP (char *comando, \fBpDatosMensaje\fP datos)"
.br
.RI "\fIEjecuta el comando NO_COMMAND\&. \fP"
.in -1c
.SH "Descripción detallada"
.PP 
Comprende los comandos restantes pedidos en la asignatura
.PP
.PP
 
.SH "Documentación de las funciones"
.PP 
.SS "\fBstatus\fP away (char *comando, \fBpDatosMensaje\fPdatos)"

.PP
Ejecuta el comando AWAY\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
status away(char *comando, pDatosMensaje datos)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIcomando\fP comando a ejecutar 
.br
\fIdatos\fP estructura con la informacion del mensaje
.RE
.PP
.SH "RETURN"
.PP
COM_OK si todo va bien\&. Error en otro caso
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "\fBstatus\fP cerrarConexion (intsocket)"

.PP
Cierra una conexion\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
status cerrarConexion(int socket)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIsocket\fP socket del usuario
.RE
.PP
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "\fBstatus\fP comandoVacio (char *comando, \fBpDatosMensaje\fPdatos)"

.PP
Ejecuta el comando NO_COMMAND\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
status comandoVacio(char *comando, pDatosMensaje datos)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIcomando\fP comando a ejecutar 
.br
\fIdatos\fP estructura con la informacion del mensaje
.RE
.PP
.SH "RETURN"
.PP
COM_OK si todo va bien\&. Error en otro caso
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "\fBstatus\fP crea_comandos (void)"

.PP
Inicializa el array de comandos\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
void liberaDatosMensaje(pDatosMensaje datos)
.fi
.PP
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "void enviarMensajeACanal (intsckfd, char *mensaje, char *canal, char *nickorigin)"

.PP
Funcion auxilar del comando PRIVMSG\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
void enviarMensajeACanal(int sckfd, char *mensaje, char *canal, char * nickorigin)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIsckfd\fP socket desde el que enviar 
.br
\fImensaje\fP mensaje a enviar 
.br
\fIcanal\fP canal al que enviar el mensaje 
.br
\fInickorig\fP nick original
.RE
.PP
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "void enviarMensajePrivado (intsckfd, char *mensaje, char *nick, char *nickorigin, intsndaway)"

.PP
Funcion auxilar del comando PRIVMSG\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
void enviarMensajePrivado(int sckfd, char *mensaje, char *nick, char * nickorigin, int sndaway)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIsckfd\fP socket desde el que enviar 
.br
\fImensaje\fP mensaje a enviar 
.br
\fInick\fP nick del usuario 
.br
\fInickorig\fP nick original 
.br
\fIsndaway\fP send away del usuario
.RE
.PP
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "char* getMOTD (void)"

.PP
Obtiene ruta del motd a mostrar\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
char * getMOTD(void)
.fi
.PP
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "\fBstatus\fP kick (char *comando, \fBpDatosMensaje\fPdatos)"

.PP
Ejecuta el comando KICK\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
status kick(char *comando, pDatosMensaje datos)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIcomando\fP comando a ejecutar 
.br
\fIdatos\fP estructura con la informacion del mensaje
.RE
.PP
.SH "RETURN"
.PP
COM_OK si todo va bien\&. Error en otro caso
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "void liberaDatosMensaje (\fBpDatosMensaje\fPdatos)"

.PP
Libera informacion del mensaje\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
void liberaDatosMensaje(pDatosMensaje datos)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIdatos\fP estructura con la informacion del mensaje
.RE
.PP
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "void liberarEstructuras (void)"

.PP
Libera estructuras antes de cerrar servidor\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
void liberarEstructuras(void)
.fi
.PP
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "\fBstatus\fP liberarUserData (char *user, char *nick, char *real, char *host, char *IP, char *away)"

.PP
Inicializa rutina ping-pong\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
status rutinaPingPong(void)
.fi
.PP
je
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 */ status \fBrutinaPingPong(void)\fP{ 
.PP
.nf
long nelements = 0;
long *ids = NULL;
char **users = NULL;
char **nicks = NULL;
char **realnames = NULL;
char **passwords = NULL;
char **hosts = NULL;
char **IPs = NULL;
int *sockets = NULL;
long *modes = NULL;
long *creationTSs = NULL;
long *actionTSs = NULL;
long i=0;



/* printf("LLAMADA A RUTINA PING PONG\n"); */
IRCTADUser_GetAllLists (&nelements,&ids,&users,&nicks,&realnames,&passwords,&hosts,&IPs,&sockets,&modes,&creationTSs,&actionTSs);

for(i=0; i< nelements; i++){

    /* printf("socket %d -> %ld\n", sockets[i], actionTSs[i]); */

}

IRCTADUser_FreeAllLists (nelements,ids,users,nicks,realnames,passwords,hosts,IPs,sockets,modes,creationTSs,actionTSs);

return COM_OK;

.fi
.PP
 }
.PP
/**
.IP "\(bu" 2
ComandosResto
.IP "\(bu" 2
Libera informacion del usuario
.IP "\(bu" 2

.PP
.SH "SYNOPSIS"
.PP
.IP "\(bu" 2
.PP
.nf
*  void liberaDatosMensaje(pDatosMensaje datos)
* 
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIuser\fP campo user de la estructura 
.br
\fInick\fP campo nick de la estructura 
.br
\fIreal\fP campo realname de la estructura 
.br
\fIhost\fP campo host de la estructura 
.br
\fIIP\fP campo dir_IP de la estructura 
.br
\fIaway\fP campo away de la estructura
.RE
.PP

.PP
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "void listarNamesCanal (char *canal, intsckfd, char *prefijo, char *nicku)"

.PP
Funcion auxiliar para el comando NAMES\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
void listarNamesCanal(char *canal, int sckfd, char *prefijo, char *nicku)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIcanal\fP canal del que obtener users 
.br
\fIsckfd\fP socket desde el que enviar 
.br
\fIprefijo\fP prefijo a utilizar 
.br
\fInicku\fP nick del user
.RE
.PP
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "void* manejaMensaje (void *pdesc)"

.PP
Parsea el mensaje recibido\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
void manejaMensaje(void* pdesc)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIpdesc\fP estructura con la informacion del mensaje
.RE
.PP
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "\fBstatus\fP mode (char *comando, \fBpDatosMensaje\fPdatos)"

.PP
Ejecuta el comando MODE\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
status mode(char *comando, pDatosMensaje datos)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIcomando\fP comando a ejecutar 
.br
\fIdatos\fP estructura con la informacion del mensaje
.RE
.PP
.SH "RETURN"
.PP
COM_OK si todo va bien\&. Error en otro caso
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "\fBstatus\fP motd (char *comando, \fBpDatosMensaje\fPdatos)"

.PP
Ejecuta el comando MOTD\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
status motd(char *comando, pDatosMensaje datos)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIcomando\fP comando a ejecutar 
.br
\fIdatos\fP estructura con la informacion del mensaje
.RE
.PP
.SH "RETURN"
.PP
COM_OK si todo va bien\&. Error en otro caso
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "\fBstatus\fP names (char *comando, \fBpDatosMensaje\fPdatos)"

.PP
Ejecuta el comando NAMES\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
status names(char *comando, pDatosMensaje datos)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIcomando\fP comando a ejecutar 
.br
\fIdatos\fP estructura con la informacion del mensaje
.RE
.PP
.SH "RETURN"
.PP
COM_OK si todo va bien\&. Error en otro caso
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "\fBstatus\fP nuevaConexion (intdesc, struct sockaddr_in *address)"

.PP
Crea una nueva conexion\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
status nuevaConexion(int desc, struct sockaddr_in * address)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIdesc\fP socket del usuario 
.br
\fIaddress\fP estructura que almacena informacion de la direccion de internet
.RE
.PP
.SH "RETURN"
.PP
el usuario temporal
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "\fBstatus\fP part (char *comando, \fBpDatosMensaje\fPdatos)"

.PP
Ejecuta el comando PART\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
status part(char *comando, pDatosMensaje datos)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIcomando\fP comando a ejecutar 
.br
\fIdatos\fP estructura con la informacion del mensaje
.RE
.PP
.SH "RETURN"
.PP
COM_OK si todo va bien\&. Error en otro caso
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "void partirCanal (intsckfd, char *canal, char *nick, char *real, char *msg)"

.PP
Funcion auxilar del comando PART\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
void partirCanal(int sckfd, char * canal, char *nick, char *real, char *msg)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIsckfd\fP socket desde el que enviar 
.br
\fIcanal\fP canal a abandonar 
.br
\fInick\fP nick del usuario 
.br
\fIreal\fP realname del usuario 
.br
\fImsg\fP mensaje a enviar
.RE
.PP
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "\fBstatus\fP ping (char *comando, \fBpDatosMensaje\fPdatos)"

.PP
Ejecuta el comando PING\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
status ping(char *comando, pDatosMensaje datos)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIcomando\fP comando a ejecutar 
.br
\fIdatos\fP estructura con la informacion del mensaje
.RE
.PP
.SH "RETURN"
.PP
COM_OK si todo va bien\&. Error en otro caso
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "\fBstatus\fP pong (char *comando, \fBpDatosMensaje\fPdatos)"

.PP
Ejecuta el comando PONG\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
status pong(char *comando, pDatosMensaje datos)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIcomando\fP comando a ejecutar 
.br
\fIdatos\fP estructura con la informacion del mensaje
.RE
.PP
.SH "RETURN"
.PP
COM_OK si todo va bien\&. Error en otro caso
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "\fBstatus\fP privmsg (char *comando, \fBpDatosMensaje\fPdatos)"

.PP
Ejecuta el comando PRIVMSG\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
status privmsg(char *comando, pDatosMensaje datos)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIcomando\fP comando a ejecutar 
.br
\fIdatos\fP estructura con la informacion del mensaje
.RE
.PP
.SH "RETURN"
.PP
COM_OK si todo va bien\&. Error en otro caso
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "\fBstatus\fP procesaComando (char *comando, \fBpDatosMensaje\fPdatos)"

.PP
Selecciona comando del array a ejecutar\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
status procesaComando(char *comando, pDatosMensaje datos)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIcomando\fP comando a ejecutar 
.br
\fIdatos\fP estructura con la informacion del mensaje
.RE
.PP
.SH "RETURN"
.PP
la funcion que ejecuta el comando
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "\fBstatus\fP quit (char *comando, \fBpDatosMensaje\fPdatos)"

.PP
Ejecuta el comando QUIT\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
status quit(char *comando, pDatosMensaje datos)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIcomando\fP comando a ejecutar 
.br
\fIdatos\fP estructura con la informacion del mensaje
.RE
.PP
.SH "RETURN"
.PP
COM_OK si todo va bien\&. Error en otro caso
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "void sendAway (intsckfd, char *away, char *nick, char *nickorig)"

.PP
Funcion auxiliar para el comando WHOIS\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
void sendAway(int sckfd, char *away, char *nick, char *nickorig)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIsckfd\fP socket desde el que enviar 
.br
\fIaway\fP mensaje away 
.br
\fInick\fP nick del usuario 
.br
\fInickorig\fP nick original
.RE
.PP
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "\fBstatus\fP topic (char *comando, \fBpDatosMensaje\fPdatos)"

.PP
Ejecuta el comando TOPIC\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
status topic(char *comando, pDatosMensaje datos)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIcomando\fP comando a ejecutar 
.br
\fIdatos\fP estructura con la informacion del mensaje
.RE
.PP
.SH "RETURN"
.PP
COM_OK si todo va bien\&. Error en otro caso
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "\fBstatus\fP whois (char *comando, \fBpDatosMensaje\fPdatos)"

.PP
Ejecuta el comando WHOIS\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
status whois(char *comando, pDatosMensaje datos)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIcomando\fP comando a ejecutar 
.br
\fIdatos\fP estructura con la informacion del mensaje
.RE
.PP
.SH "RETURN"
.PP
COM_OK si todo va bien\&. Error en otro caso
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SS "void whoischannels (intsckfd, char *nick1, char *nick2, char *user, char *target)"

.PP
Funcion auxiliar para el comando WHOIS\&. 
.SH "SYNOPSIS"
.PP
.PP
.nf
void whoischannels(int sckfd, char *nick1, char *nick2, char* user, char *target)
.fi
.PP
.PP
\fBParámetros:\fP
.RS 4
\fIsckfd\fP socket desde el que enviar 
.br
\fInick1\fP nick necesario numero 1 
.br
\fInick2\fP nick necesario numero 2 
.br
\fIuser\fP usuario del canal 
.br
\fItarget\fP objetivo
.RE
.PP
.SH "AUTHOR"
.PP
Pablo Marcos Manchon Dionisio Perez Alvear
.PP
.PP
 
.SH "Autor"
.PP 
Generado automáticamente por Doxygen para Practica RedesII del código fuente\&.
